<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>PolyBubbles: Airy Motion</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap');
        :root { 
            --poly-bg: #030816; --poly-blue: #2458f0; --poly-blue-glow: rgba(36, 88, 240, 0.4);
            --poly-green: #00d395; --poly-red: #ff4a5a; --poly-text: #ffffff;
        }
        body { 
            margin: 0; background: var(--poly-bg); overflow: hidden; 
            font-family: 'Inter', sans-serif; color: var(--poly-text);
            background-image: radial-gradient(circle at 20% 20%, #0a132e 0%, #030816 100%);
        }
        .header {
            position: absolute; top: 0; left: 0; right: 0; padding: 14px 24px;
            background: rgba(3, 8, 22, 0.8); backdrop-filter: blur(20px);
            border-bottom: 1px solid rgba(255,255,255,0.08); z-index: 100;
            display: flex; justify-content: space-between; align-items: center; pointer-events: none;
        }
        .header * { pointer-events: auto; }
        .logo-wrapper { display: flex; align-items: center; gap: 10px; text-decoration: none; }
        .poly-icon {
            width: 32px; height: 32px; background: var(--poly-blue); border-radius: 8px;
            display: flex; align-items: center; justify-content: center; box-shadow: 0 0 15px var(--poly-blue-glow);
        }
        .poly-icon::after { content: "P"; color: white; font-weight: 800; font-size: 20px; }
        .logo-brand { font-size: 20px; font-weight: 700; color: white; letter-spacing: -0.3px; }
        .logo-sub { color: var(--poly-blue); font-weight: 800; }
        .live-status {
            background: rgba(0, 211, 149, 0.1); border: 1px solid rgba(0, 211, 149, 0.2);
            padding: 4px 10px; border-radius: 20px; display: flex; align-items: center; gap: 8px;
        }
        .dot { width: 6px; height: 6px; background: var(--poly-green); border-radius: 50%; box-shadow: 0 0 8px var(--poly-green); }
        .status-text { font-size: 11px; font-weight: 600; color: var(--poly-green); text-transform: uppercase; }
        svg { display: block; width: 100vw; height: 100vh; }
        .bubble-group { cursor: grab; }
        .bubble-ui {
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            height: 100%; width: 100%; text-align: center; padding: 5px; box-sizing: border-box; pointer-events: none;
        }
        .title { font-size: 8px; line-height: 1.1; font-weight: 400; opacity: 0.7; color: #fff; margin-bottom: 2px; }
        .value { font-size: 16px; font-weight: 800; color: #fff; }
        .volume { font-size: 7px; font-weight: 600; opacity: 0.5; }
    </style>
</head>
<body>
<div class="header">
    <div class="logo-wrapper">
        <div class="poly-icon"></div>
        <div class="logo-brand">Poly<span class="logo-sub">Bubbles</span></div>
    </div>
    <div class="live-status"><div class="dot"></div><span class="status-text" id="sync-info">Syncing...</span></div>
</div>
<script>
    const width = window.innerWidth, height = window.innerHeight, topPadding = 120;
    const svg = d3.select("body").append("svg").attr("width", width).attr("height", height);
    const defs = svg.append("defs");
    let nodes = [];

    const createGrad = (id, color) => {
        const grad = defs.append("radialGradient").attr("id", id).attr("cx", "40%").attr("cy", "40%");
        grad.append("stop").attr("offset", "0%").attr("stop-color", "#ffffff").attr("stop-opacity", 0.4);
        grad.append("stop").attr("offset", "100%").attr("stop-color", color).attr("stop-opacity", 0.3);
    };
    createGrad("grad-green", "#00d395"); createGrad("grad-blue", "#2458f0"); createGrad("grad-red", "#ff4a5a");

    const simulation = d3.forceSimulation(nodes)
        .force("charge", d3.forceManyBody().strength(10)) // Слабое расталкивание для "воздуха"
        .force("x", d3.forceX(width / 2).strength(0.008)) // Очень слабое притяжение к центру
        .force("y", d3.forceY((height + topPadding) / 2).strength(0.008))
        .force("collide", d3.forceCollide().radius(d => d.radius + 15).iterations(10)) // Большой зазор
        .alphaTarget(0.2) // Высокая активность для постоянного движения
        .on("tick", () => {
            nodes.forEach(d => {
                // ПЛАВАЮЩЕЕ ДВИЖЕНИЕ
                d.vx += (Math.random() - 0.5) * 0.25;
                d.vy += (Math.random() - 0.5) * 0.25;

                // Границы экрана
                d.x = Math.max(d.radius + 20, Math.min(width - d.radius - 20, d.x));
                d.y = Math.max(d.radius + topPadding, Math.min(height - d.radius - 20, d.y));
            });
            svg.selectAll(".bubble-group").attr("transform", d => `translate(${d.x},${d.y})`);
        });

    function render(newData) {
        // Оставляем 40 шаров, но делаем их МЕНЬШЕ
        const filteredData = newData.sort((a, b) => b.pnl - a.pnl).slice(0, 40);
        const totalVolume = d3.sum(filteredData, d => d.pnl);
        const maxVol = d3.max(filteredData, d => d.pnl) || 1000;
        const avgVol = d3.mean(filteredData, d => d.pnl) || 500;

        // НОВЫЙ МАСШТАБ: от 20 до 65 пикселей (было 30-85)
        const radiusScale = d3.scaleSqrt().domain([0, maxVol]).range([20, 65]);

        nodes = filteredData.map(d => {
            let existing = nodes.find(n => n.label === d.label);
            const r = radiusScale(d.pnl);
            if (existing) {
                existing.pnl = d.pnl; existing.radius = r;
                existing.share = ((d.pnl / totalVolume) * 100).toFixed(1) + "%";
                return existing;
            }
            return { ...d, radius: r, x: Math.random()*width, y: Math.random()*height, share: ((d.pnl / totalVolume) * 100).toFixed(1) + "%" };
        });

        const bubbles = svg.selectAll(".bubble-group").data(nodes, d => d.label);
        bubbles.exit().remove();

        const gEnter = bubbles.enter().append("g").attr("class", "bubble-group")
            .call(d3.drag()
                .on("start", (e, d) => {
                    d.startX = e.x; d.startY = e.y;
                    if (!e.active) simulation.alphaTarget(0.4).restart();
                    d.fx = d.x; d.fy = d.y;
                })
                .on("drag", (e, d) => { d.fx = e.x; d.fy = e.y; })
                .on("end", (e, d) => {
                    if (!e.active) simulation.alphaTarget(0.2);
                    d.fx = null; d.fy = null;
                    const dist = Math.sqrt(Math.pow(e.x - d.startX, 2) + Math.pow(e.y - d.startY, 2));
                    if (dist < 6) window.open(d.link, "_blank");
                })
            );

        gEnter.append("circle").attr("class", "glow").style("filter", "blur(15px)").attr("opacity", 0.3);
        gEnter.append("circle").attr("class", "main-circle").attr("stroke", "rgba(255,255,255,0.08)");
        
        const foreign = gEnter.append("foreignObject").attr("class", "text-box");
        const div = foreign.append("xhtml:div").attr("class", "bubble-ui");
        div.append("div").attr("class", "title");
        div.append("div").attr("class", "value");
        div.append("div").attr("class", "volume");

        const all = svg.selectAll(".bubble-group");
        const hT = avgVol * 1.1, mT = avgVol * 0.9;

        all.select(".glow").attr("r", d => d.radius + 8)
            .attr("fill", d => d.pnl >= hT ? "#00d395" : (d.pnl >= mT ? "#2458f0" : "#ff4a5a"));
        all.select(".main-circle").attr("r", d => d.radius)
            .attr("fill", d => d.pnl >= hT ? "url(#grad-green)" : (d.pnl >= mT ? "url(#grad-blue)" : "url(#grad-red)"));
        all.select(".text-box").attr("x", d => -d.radius).attr("y", d => -d.radius).attr("width", d => d.radius * 2).attr("height", d => d.radius * 2);
        all.select(".title").text(d => d.label.length > 25 ? d.label.slice(0, 22) + '..' : d.label);
        all.select(".value").text(d => d.share);
        all.select(".volume").text(d => (d.pnl/1000).toFixed(1) + "K");

        simulation.nodes(nodes);
        simulation.alpha(1).restart();
    }

    async function updateData() {
        try {
            const r = await fetch('/api'); const d = await r.json();
            if (d.length > 0) {
                document.getElementById('sync-info').innerText = "LIVE: " + new Date().toLocaleTimeString();
                render(d);
            }
        } catch (e) { console.error(e); }
    }
    updateData(); setInterval(updateData, 15000);
</script>
</body>
</html>